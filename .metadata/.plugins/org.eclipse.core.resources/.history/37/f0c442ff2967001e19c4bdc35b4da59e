/*
 * M66.h
 *
 *  Created on: Aug 30, 2023
 *      Author: atiqueshaikh
 */

#ifndef INC_M66_H_
#define INC_M66_H_

#include "stm32f4xx_hal.h"
#include "main.h"
#include "stdbool.h"

extern UART_HandleTypeDef huart2;




// Addresses for the bootloader, config, app, and temp sections
#define BOOTLOADER_START_ADDR   0x8000000  // Start address of the bootloader section
#define CONFIG_START_ADDR       0x8020000  // Start address of the config section
#define APP_START_ADDR          0x8040000  // Start address of the app section
#define TEMP_START_ADDR         0x80C0000  // Start address of the temp section
#define TEMP_SECTION_SIZE       0x40000     // Size of the temp section (396KB)
#define CONFIG_END_ADDR			CONFIG_START_ADDR + 0x10000
#define FIRMWARE_SIZE_ADDR		0x8020004

#define MAX_URL_LENGTH 256
extern char firmware_url[MAX_URL_LENGTH];
extern uint8_t received_byte;
extern volatile bool data_received_flag;// Change type if needed
extern uint8_t receive_buffer[]; // Change type and size if needed

#define BUFFER_MAX_SIZE 256


// Global variables and buffers specific to MQTT
#define MQTT_BUFFER_SIZE 512



#define MAX_FIRMWARE_SIZE 51200 // Adjust as needed
// Firmware buffer
extern uint8_t firmware_buffer[MAX_FIRMWARE_SIZE];
extern uint32_t firmware_size;

#define CRC_POLYNOMIAL         0x04C11DB7  // CRC32 polynomial




uint32_t receive_data(uint8_t* buffer, uint32_t buffer_size);
uint32_t calculate_crc32(uint8_t* data, uint32_t size);
bool verify_firmware_update();
bool download_firmware(const char* firmware_url);
void handle_mqtt_message(const char* message);
void Initialize_Modem(void);
void SSL_Config(void);
void AWS_MQTT(void);
void handle_mqtt_byte(uint8_t byte);
void handle_default_byte(uint8_t byte);
bool is_firmware_size_valid(uint32_t firmware_length);
uint32_t extract_received_crc(uint8_t* firmware_data, uint32_t firmware_length);
bool set_update_flag(void);
void firmware_update_handler(void);
void resetAction();
bool firmware_update_process();
bool find_end_marker(uint8_t *buffer, uint32_t size);
void clear_uart_buffer ();
uint8_t* find_end_marker_position(uint8_t *buffer, uint32_t size);
bool check_for_uart_error();

HAL_StatusTypeDef erase_flash(uint32_t start_address, uint32_t end_address);
uint32_t get_flash_sector(uint32_t address);
HAL_StatusTypeDef write_to_flash(uint32_t address, uint8_t *data, uint32_t length);


#define UART_BUFFER_SIZE 256

typedef struct {
    uint8_t data[UART_BUFFER_SIZE];
    uint16_t write_index;
    uint16_t read_index;
} UART_BufferTypeDef;

extern UART_BufferTypeDef uart_buffer;
enum FwUpdateState {
    IDLE,
    DOWNLOAD_PENDING,
    VERIFY_PENDING,
    WRITE_PENDING,
    RESET_PENDING,
    ACTION_IN_PROGRESS,
    ERROR_STATE
};
extern enum FwUpdateState fwUpdateState;
bool actionStarted(enum FwUpdateState state);
void handleRetry(enum FwUpdateState state);

typedef enum {
    MODE_DEFAULT,
    MODE_MQTT
} UART_Mode;

extern UART_Mode current_mode;

typedef enum {
    INIT_HTTP,
    SET_HTTP_URL,
    INITIATE_HTTP_GET,
    RECEIVE_HTTP_RESPONSE,
    DOWNLOAD_COMPLETE,
    DOWNLOAD_ERROR
} download_state_t;
extern download_state_t current_state;

typedef enum {
    WAIT_FOR_CONNECT,
    RECEIVE_DATA,
    WRITE_TO_FLASH,
    DOWNLOAD_DONE,
    DOWNLOAD_FAILED
} UpdateState;
extern UpdateState current_update_state;

#endif /* INC_M66_H_ */
