/*
 * bootloader.c
 *
 *  Created on: Oct 10, 2023
 *      Author: sghute
 */

#include "bootloader.h"
#include "main.h"
#include <stdint.h>
#include <string.h>
#include "stdbool.h"

// Addresses for the bootloader, config, app, and temp sections
#define BOOTLOADER_START_ADDR   0x8000000  // Start address of the bootloader section
#define CONFIG_START_ADDR       0x8020000  // Start address of the config section
#define APP_START_ADDR          0x8040000  // Start address of the app section
#define TEMP_START_ADDR         0x80C0000  // Start address of the temp section
#define TEMP_SECTION_SIZE       0x40000     // Size of the temp section (256KB)
#define APP_SECTION_SIZE		0x60000
#define APP_END_ADDR			APP_START_ADDR + APP_SECTION_SIZE
#define CONFIG_END_ADDR			CONFIG_START_ADDR + 0x10000
#define FIRMWARE_SIZE_ADDR		0x8020004


#define BOOTLOADER_TIMEOUT_MS				5000
#define CRC_POLYNOMIAL						0x04C11DB7
#define UPDATE_FLAG_VALUE					0xDEADBEEF
#define UPDATE_FLAG_RESET_VALUE				0xFFFFFFFF



void bootloader_function(void){
    uint32_t *config_flag = (uint32_t *)CONFIG_START_ADDR;

    if (*config_flag == UPDATE_FLAG_VALUE) {
        // Calculate CRC32 of the new firmware in the TEMP section
//        uint32_t calculated_crc = calculate_crc32((uint8_t *)TEMP_START_ADDR, TEMP_SECTION_SIZE);
        uint32_t *end_marker = (uint32_t *)(TEMP_START_ADDR + TEMP_SECTION_SIZE);

//        if (calculated_crc == 0x0) {
            uint32_t new_firmware_size = (uint32_t)(end_marker - (uint32_t *)TEMP_START_ADDR);

            if (!update_application(new_firmware_size)) {
                // Handle firmware update error, maybe flash a specific LED
            }
//        } else {
//            // Handle CRC mismatch error, maybe flash a specific LED
//        }
    }
	   // Handle timeout (if needed)
	   uint32_t start_time = HAL_GetTick();
	   while (!is_timeout_expired(start_time, BOOTLOADER_TIMEOUT_MS)) {
	       // Your bootloader code can have additional functionality here
	   }

	   // Jump to the application
	   jump_to_application(APP_START_ADDR);

}

// Function to update the application with error handling
bool update_application(uint32_t app_size) {
//    uint32_t *temp_src = (uint32_t *)TEMP_START_ADDR;
//    uint32_t *app_dest = (uint32_t *)APP_START_ADDR;


    if (HAL_OK != erase_flash(APP_START_ADDR, APP_END_ADDR)) {
        // Handle error: Erasing flash failed
        return false;     // Return an error
    }

    // Check if the new binary size is valid
    if (HAL_OK != transfer_flash_data(TEMP_START_ADDR, APP_START_ADDR, TEMP_SECTION_SIZE)) {
        return false;
    }

    // Reset the flag in the config section
    if (HAL_OK != erase_flash(CONFIG_START_ADDR, CONFIG_END_ADDR)) {
        // Handle error: Erasing flash failed
        return false;     // Return an error
    }
    return true; // Indicate successful update
}

