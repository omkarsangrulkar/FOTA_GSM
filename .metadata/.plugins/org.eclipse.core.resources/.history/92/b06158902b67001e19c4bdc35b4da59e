/*
 * bootloader.c
 *
 *  Created on: Oct 10, 2023
 *      Author: sghute
 */

#include "bootloader.h"
#include "main.h"
#include <stdint.h>
#include <string.h>
#include "stdbool.h"

// Addresses for the bootloader, config, app, and temp sections
#define BOOTLOADER_START_ADDR   0x8000000  // Start address of the bootloader section
#define CONFIG_START_ADDR       0x8020000  // Start address of the config section
#define APP_START_ADDR          0x8040000  // Start address of the app section
#define TEMP_START_ADDR         0x80C0000  // Start address of the temp section
#define TEMP_SECTION_SIZE       0x40000     // Size of the temp section (256KB)
#define APP_SECTION_SIZE		0x60000
#define APP_END_ADDR			APP_START_ADDR + APP_SECTION_SIZE
#define CONFIG_END_ADDR			CONFIG_START_ADDR + 0x10000
#define FIRMWARE_SIZE_ADDR		0x8020004


#define BOOTLOADER_TIMEOUT_MS				5000
#define CRC_POLYNOMIAL						0x04C11DB7
#define UPDATE_FLAG_VALUE					0xDEADBEEF
#define UPDATE_FLAG_RESET_VALUE				0xFFFFFFFF



void bootloader_function(void){
    uint32_t *config_flag = (uint32_t *)CONFIG_START_ADDR;

    if (*config_flag == UPDATE_FLAG_VALUE) {
        // Calculate CRC32 of the new firmware in the TEMP section
//        uint32_t calculated_crc = calculate_crc32((uint8_t *)TEMP_START_ADDR, TEMP_SECTION_SIZE);
        uint32_t *end_marker = (uint32_t *)(TEMP_START_ADDR + TEMP_SECTION_SIZE);

//        if (calculated_crc == 0x0) {
            uint32_t new_firmware_size = (uint32_t)(end_marker - (uint32_t *)TEMP_START_ADDR);

            if (!update_application(new_firmware_size)) {
                // Handle firmware update error, maybe flash a specific LED
            }
//        } else {
//            // Handle CRC mismatch error, maybe flash a specific LED
//        }
    }
	   // Handle timeout (if needed)
	   uint32_t start_time = HAL_GetTick();
	   while (!is_timeout_expired(start_time, BOOTLOADER_TIMEOUT_MS)) {
	       // Your bootloader code can have additional functionality here
	   }

	   // Jump to the application
	   jump_to_application(APP_START_ADDR);

}

// Function to update the application with error handling
bool update_application(uint32_t app_size) {
//    uint32_t *temp_src = (uint32_t *)TEMP_START_ADDR;
//    uint32_t *app_dest = (uint32_t *)APP_START_ADDR;


    if (HAL_OK != erase_flash(APP_START_ADDR, APP_END_ADDR)) {
        // Handle error: Erasing flash failed
        return false;     // Return an error
    }

    // Check if the new binary size is valid
    if (HAL_OK != transfer_flash_data(TEMP_START_ADDR, APP_START_ADDR, TEMP_SECTION_SIZE)) {
        return false;
    }

    // Reset the flag in the config section
    if (HAL_OK != erase_flash(CONFIG_START_ADDR, CONFIG_END_ADDR)) {
        // Handle error: Erasing flash failed
        return false;     // Return an error
    }
    return true; // Indicate successful update
}


// Function pointer to the application
typedef void (*pFunction)(void);

//void bootloader_function(void) __attribute__((section(".bootloader")));

void jump_to_application(uint32_t app_address) {
    // 1. Define application entry and stack pointer
    uint32_t app_stack_pointer = *(volatile uint32_t*)app_address;
    pFunction app_entry = (pFunction)(*(volatile uint32_t*)(app_address + 4));

    // 2. Disable all interrupts
//    __disable_irq();

    // 3. Reset all peripherals (optional but recommended)
    HAL_DeInit();

    // 4. Clear any pending system interrupts. Especially if a SysTick is running, it should be stopped.
    SysTick->CTRL = 0;
    SysTick->LOAD = 0;
    SysTick->VAL = 0;

    // 5. Reset the RCC clock configuration to the default reset state
    // -- Reset the RCC clock configuration to the default reset state
    // -- Disable all peripherals clock
    // -- Update the SystemCoreClock variable
    HAL_RCC_DeInit();

    // 6. Set the vector table base address
//    SCB->VTOR = app_address;

    // 7. Initialize master stack pointer with application stack pointer
    __set_MSP(app_stack_pointer);

    // 8. Jump to the application
    app_entry();
}

// Function to calculate a simple checksum
// Manual CRC32 calculation
uint32_t calculate_crc32(uint8_t *data, uint32_t size) {
    uint32_t crc = 0xFFFFFFFF;

    for (uint32_t i = 0; i < size; i++) {
        crc ^= ((uint32_t)data[i]) << 24;

        for (uint32_t j = 0; j < 8; j++) {
            if (crc & 0x80000000) {
                crc = (crc << 1) ^ CRC_POLYNOMIAL;
            } else {
                crc = crc << 1;
            }
        }
    }

    return crc;
}

uint32_t get_flash_sector(uint32_t address) {
    uint32_t sector;

    // STM32F407VG flash sectors
    if (address < 0x08004000) sector = FLASH_SECTOR_0;
    else if (address < 0x08008000) sector = FLASH_SECTOR_1;
    else if (address < 0x0800C000) sector = FLASH_SECTOR_2;
    else if (address < 0x08010000) sector = FLASH_SECTOR_3;
    else if (address < 0x08020000) sector = FLASH_SECTOR_4;
    else if (address < 0x08040000) sector = FLASH_SECTOR_5;
    else if (address < 0x08060000) sector = FLASH_SECTOR_6;
    else if (address < 0x08080000) sector = FLASH_SECTOR_7;
    else if (address < 0x080A0000) sector = FLASH_SECTOR_8;
    else if (address < 0x080C0000) sector = FLASH_SECTOR_9;
    else if (address < 0x080E0000) sector = FLASH_SECTOR_10;
    else sector = FLASH_SECTOR_11;  // covers up to 0x08100000

    return sector;
}
